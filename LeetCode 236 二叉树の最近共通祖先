LeetCode 236 二叉树の最近共通祖先
class Solution {
public: //主関数の主な操作は、2つのシーケンスの中で最後に等しいノードを見つけることです
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        vector<TreeNode*> path;
        vector<TreeNode*> path_p;
        vector<TreeNode*> path_q;
        dfs(root,p,q,path,path_p,path_q);
        TreeNode* res = NULL;
        for(int i=0;i<min(path_p.size(),path_q.size());i++){
            if(path_p[i] == path_q[i]){
                res = path_p[i];
            }else{
                break;
            }
        }
        return res;
    }
    //再帰三部作：深さ優先探索
    //1 再帰関数の戻り値と引数を確定する
    //path：一時的な経路を保存するために使用します
    //nodeは現在探索しているノードを表します
    //path_p：根ノードからpノードまでに含まれるすべてのノード
    //path_q：根ノードからqノードまでに含まれるすべてのノード
    dfs(TreeNode* node,TreeNode* p,TreeNode* q,vector<TreeNode*>& path,vector<TreeNode
    *>& path_p,vector<TreeNode*>& path_q){
        //2 終了条件。現在のノードが空であるか、pとqが両方とも見つかった場合は直接返ります
        if(node == NULL|| (path_p.size() != 0 && path_q.size() != 0)){
            return ;
        }
        //3 単層のループ操作を確定する
        //現在のノードをpathに追加します
        path.push_back(node);
        if(node == p) path_p = path;  //pノードを見つけた
        if(node == q) path_q = path; //qノードを見つけた
        // qとpのどちらかが見つかっていない場合は再帰的に下に進みます
        if(path_p.empty()|| path_q.empty()){
            dfs(node->left,p,q,path,path_p,path_q);
            dfs(node->right,p,q,path,path_p,path_q);
        }
        //nodeからpathをポップします
        path.pop_back();
    }
};
