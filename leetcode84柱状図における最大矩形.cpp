class Solution {
public:
    int largestRectangleArea(vector<int>& h) {
        // 単調スタックの応用シーン：
        // ・ある要素の「右側または左側で最初に現れる、それより大きいまたは小さい要素」を求める
        // 本題では「単調減少スタック」を使用する
        // コアアイデア：
        // ・各要素について、「左側で最初に現れるそれより小さい要素」と「右側で最初に現れるそれより小さい要素」を見つける
        // ・左側の小さい要素は、スタックのトップの次の要素（スタックが単調減少なので）
        // ・右側の小さい要素は、比較時に発見される

        // 前処理：配列の先頭と末尾に0を追加する（境界条件の処理を簡略化）
        h.insert(h.begin(), 0); // 先頭に0を挿入
        h.push_back(0);         // 末尾に0を追加

        stack<int> st; // 右側で最初に現れる小さい要素を探すための単調減少スタック（インデックスを保存）
        st.push(0);    // 最初の要素（0）のインデックスをスタックにプッシュ
        int result = 0; // 最大面積を保存する変数

        // 配列を走査する
        for (int i = 0; i < h.size(); i++) {
            // 現在の要素がスタックトップの要素より大きい場合
            if (h[i] > h[st.top()]) {
                st.push(i); // インデックスをスタックにプッシュ
            } 
            // 現在の要素がスタックトップの要素と等しい場合
            else if (h[i] == h[st.top()]) {
                st.push(i); // インデックスをスタックにプッシュ（重複可能）
            } 
            // 現在の要素がスタックトップの要素より小さい場合（面積計算のタイミング）
            else {
                while (!st.empty() && h[i] < h[st.top()]) {
                    int mid = st.top(); // スタックトップのインデックス（高さの基準となる棒）
                    int height = h[mid]; // 現在の棒の高さ
                    st.pop(); // スタックからポップ

                    // スタックが空でない場合、左右の境界から幅を計算
                    if (!st.empty()) {
                        int right = i;       // 右境界（現在の要素のインデックス）
                        int left = st.top(); // 左境界（新しいスタックトップのインデックス）
                        int width = right - left - 1; // 幅 = 右境界 - 左境界 - 1
                        result = max(result, width * height); // 最大面積を更新
                    }
                }
                // 現在の要素のインデックスをスタックにプッシュ（後続の比較用）
                st.push(i);
            }
        }
        return result; // 最大面積を返す
    }
};